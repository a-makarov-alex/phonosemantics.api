Последние правки:
05-07-2021 - класс report/PatternSquare

Как работать с паттерном
А. Что ожидается.
1. В обработку входит вордлист.
2. Он парсится и начинает состоять из транскрипции, разбитой на дифференциальные признаки. Таким образом, каждой фонеме в слове начинает соответствовать целый набор признаков, который в полном виде нечитаем. Более того, из этого набора значимым для исследования будет только один (или несколько) доминантных признаков.
3. Таким образом, результатом парсинга вордлиста становится некоторое число доминантных паттернов.

Вопросы:
1.1 Какого уровня эти паттерны? Верхний - типа гласная-согласная. Нижний - с высокой степенью дробления признаков.
1.2 Как сравнивать доминантность признаков разного уровня? вариантов гласная-согласная будет всегда больше, чем более узких
1.3 Можно ли их смешивать? Вариант "любая гласная + конкретный тип согласных", например, может быть очень показателен.
2. Сколько этих паттернов ожидается?
3. По какому принципу определяется доминантность?
4.1 В какой форме будут выводиться эти паттерны?
4.2 Кодировка - это неэффективно, т.к. принцип забывается, требует времени на дешифровку и непоказателен для посторонних
4.3 Графический отчет - как его строить?

Если брать последовательность из пары признаков, например: "после гласной идёт: " и далее сравнивается признак, который идёт чаще всего.
Проблемы:
1. Огромный объем данных ввиду комбинаторики. Признаки комбинируются "все со всеми".
2. Самые популярные паттерны будут оказываться доминирующими вне зависимости от вордлиста, просто на основании употребимости тех или иных фонем. Например, билабиальных будет гарантированно больше, чем аффрикат. И паттернов с ними очевидно будет больше.

Таким образом, паттерны интересны в сравнении вордлистов, а не в отрыве. Либо в отрыве, но с сохранением данных и возможностью последующего сравнения.
А1. Очевидно, самый простой тестовый вариант реализации: гласный-согласный. Здесь имеется строгий уровень (один), отсутствие комбинаторики как таковой. Но как такую модель дальше расширять?
А2. Предположим, оставляем гласный + согласный по способу образования. Комбинаторика малочисленна, однако уровень детализации разный; игнорируются признаки согласных по месту образования; т.е. результат автоматически не полон.
А3. Предположим, используется матричный подход: по вертикали и горизонтали отложены все признаки гласных и согласных. Место пересечения означает последовательность из двух звуков, где, например, первый - по вертикали, второй - по горизонтали. В выбранную ячейку инкрементится единица. По итогу получается матрица, заполненная цифрами - ячейки с наибольшими числами - это наиболее популярные паттерны.
А4. Теоретически, такой подход расширяем до трехмерной матрицы, получится что-то похожее на вектора.
А5. Плюсы подхода А3: 
- Результат человекочитаем
- Можно как детализировать, так и абстрагировать масштаб до нужных категорий. В частности, матрица 2*2 (гласные-согласные) тоже легко реализуема. либо 3*3 (гласные-полугласные-согласные)
- Не требуется кодирование результата
А6. Минусы подхода А3:
- Не подходит для передачи входных данных (запроса паттерна)
- Последовательность из 3 символов всё равно графически не отобразима (требуется 3D)




свежие примечания (06-2021):
- преобразование DistFeatures в Map<> делается динамически, хотя вообще-то это просто справочник
- добавить в "квадрат" паттерны: "Начало слова" + первый признак" и "последний признак + конец слова"

(10-07-2021):
+ закрасить темно серым строки и столбцы not applicable, они не показательны
- закрашивать цветами разной интенсивности ячейки с наибольшими цифрами в таблице
- продумать "схлопывающуюся" таблицу с паттернами типа "ТИП" + "ПОДТИП" (любая гласная + латеральный), например. И наоборот: подтип + тип
- написать тесты, чтобы понимать что паттерны анализируются корректно
--- добавить json для фонем
--- парсить их для нужной пары
--- проверять (рефлексивно?), что в таблице поля проставлены корректно
- ДОБАВИТЬ ПОПУЛЯРНЫЕ ФОНЕМЫ типа h
- продумать как реагировать приложению на неизместные фонемы и как сделать, чтоб оно не падало
- реализовать поиск самых популярных 3-значных паттернов. Таблицей не получится (это 3-мерная матрица), но можно выводить список самых частых. Продумать.


14.12.2021
- оптимизировать код с помощью стримов

!!!
Я ОТКЛАДЫВАЮ РАБОТУ НАД ИССЛЕДОВАНИЕМ, ПОТОМУ ЧТО
1. НЕ УВЕРЕН В КОННЕКТНОСТИ РАБОТЫ ПРОГРАММЫ
2. КАЖДЫЙ РАЗ ЗАНОВО ВСПОМИНАЮ КАК ОНА РАБОТЕТ
Если решить пункт 2 и добавить прзрачности, пункт 1 также станет менее острым.
Комментарии по эндпойнтам ниже.

Сервис Wordlist:
/meanings - всё ок
/wordlist - много данных возвращается. оставить только сами слова, без фонетики и статистики
/wordlists - аналогично
/wordlists/{meaning}/features/stats - неясно, что такое [query] type, какие у него доступны значения.
Параметры для СТАТИСТИКИ numAllPhonemes, numAllWords надо вынести из разделов на верхний уровень джейсона и хранить один раз.
Сейчас они хранятся (одинаковые!) в каждом блоке статистики по каждому параметру.
/wordlists/{meaning}/phonemes - много выходных данных. Резонно оставить только фонему и статистику (?) по ней. изменить роут на: .../phonemes/all/stats
/wordlists/{meaning}/phonemes/stats - всё ок. только неочевидно, что с прошлым энпойнтом разница в наличии query по фонеме
/wordlists/features/{feature}/stats - надо централизовано хранить список значений feature.

Сервис Word - всё ок

Сервис Phonemes
/phonemes/{type} - что это вообще? для какого вордлиста? значения для type указать возможные
/phonemes/headers/{feature} - неясно как пользоваться
/phonemes/table/{type} - значения для type указать возможные. Служебный эндпойнт? зачем он тогда открытый?

Сервис Phonemes bank - для какого вордлиста? почему numOfAllWords = 1 ???
